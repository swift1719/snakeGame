{"version":3,"sources":["utils/boardUtil.js","utils/singlyLL.js","utils/snakeUtil.js","utils/coordUtil.js","assets/snake.png","board/aside.js","assets/borderGolden.png","assets/apple.png","assets/borderLeaves.png","assets/frog.png","board/board.js","utils/intervalUtil.js","App.js","index.js"],"names":["isOutOfBounds","coordinates","board","row","col","length","LinkedListNode","value","this","next","SinglyLinkedList","node","head","tail","getStartingSnakeCell","rowSize","colSize","startingRow","Math","round","startingCol","cell","Direction","getOppostiteDirection","direction","getNextNodeDirection","currentDirection","currentRow","currentCol","nextRow","nextCol","getNextCoordInDirection","currentCoord","Aside","className","width","src","snakeImg","alt","Board","useState","BOARD_SIZE","counter","push","createBoard","snake","setSnake","Set","snakeCells","setSnakeCells","snakeCellsHookRef","useRef","foodCell","setFoodCell","setDirection","directionHookRef","_setDirection","current","foodShouldReverseDirection","setFoodShouldReverseDirection","score","setScore","useEffect","window","addEventListener","e","handleKeydown","callback","delay","savedCallback","id","setInterval","clearInterval","useInterval","moveSnake","newDirection","key","getDirectionFromKey","size","currentHeadCoordinates","nextHeadCoordinates","handleGameOver","nextHeadCell","has","newHead","currentHead","newSnakeCells","delete","add","growSnake","reverseSnake","handleFoodConsumption","_setSnakeCells","growthNodeCoords","snakeTail","tailNextNodeDirection","growthDirection","currentTailCoords","getGrowthNodeCoords","newTailCell","newTail","currentTail","previousNode","currentNode","nextNode","reverseLinkedList","snakeHead","nextFoodCell","min","max","floor","random","nextFoodShouldReverseDirection","snakeLLStartingValue","style","marginTop","height","GreenBoard","map","rowInd","cellValue","cellInd","getCellClassName","scoreBoardImg","textDecorationLine","marginLeft","appleImg","position","color","marginRight","frogImg","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.66a7247e.chunk.js","sourcesContent":["export const createBoard = BOARD_SIZE => {\r\n    let counter=1;\r\n    const board=[];\r\n\r\n    for(let row=0;row<BOARD_SIZE;row++){\r\n        const currentRow=[];\r\n        for(let col=0;col<BOARD_SIZE;col++){\r\n            currentRow.push(counter++);\r\n        }//every cell of board has a unique counter\r\n        board.push(currentRow);\r\n    }\r\n    return board;\r\n}\r\n\r\nexport const isOutOfBounds=(coordinates,board)=>{\r\n    const {row,col}=coordinates;\r\n    if(row<0 || col<0)return true;\r\n    if(row>=board.length || col>=board[0].length)return true;\r\n    return false;\r\n}\r\nexport const getCellClassName=(cellValue,foodCell,foodShouldReverseDirection,snakeCells)=>{\r\n    let className='cell';\r\n    if(cellValue===foodCell){\r\n        if(foodShouldReverseDirection){\r\n            className ='cell cell-purple';\r\n        }else{\r\n            className='cell cell-red';\r\n        }\r\n    }\r\n    if(snakeCells.has(cellValue)){\r\n        className='cell cell-green';\r\n    }\r\n    return className;\r\n}\r\n","export class LinkedListNode{\r\n    constructor(value){\r\n        this.value=value;//value :{row: , col: ,cell: }\r\n        this.next=null;\r\n    }\r\n}\r\nexport class SinglyLinkedList{\r\n    constructor(value){\r\n        const node=new LinkedListNode(value);\r\n        this.head=node;\r\n        this.tail=node;\r\n    }\r\n}\r\nexport function reverseLinkedList(head){\r\n    let previousNode=null;\r\n    let currentNode=head;\r\n    while(currentNode!==null){\r\n        const nextNode=currentNode.next;\r\n        currentNode.next=previousNode;\r\n        previousNode=currentNode;\r\n        currentNode=nextNode;\r\n    }\r\n    return previousNode;\r\n}","export const getStartingSnakeCell=board=>{\r\n    const rowSize = board.length;\r\n    const colSize = board[0].length;\r\n    const startingRow=Math.round(rowSize/3);\r\n    const startingCol=Math.round(colSize/3);\r\n    const startingCell=board[startingRow][startingCol];\r\n    return{\r\n        row:startingRow,\r\n        col:startingCol,\r\n        cell:startingCell\r\n    }\r\n}\r\nexport function randomIntFromInterval(min,max){\r\n    return Math.floor(Math.random()*(max-min+1)+min)\r\n}\r\n","//hashtable to return direction\r\nexport const Direction={\r\n    UP:'UP',\r\n    RIGHT:'RIGHT',\r\n    DOWN:'DOWN',\r\n    LEFT:'LEFT',\r\n};\r\nexport const getDirectionFromKey = key=>{\r\n    switch (key) {\r\n        case 'ArrowUp':\r\n            return Direction.UP;\r\n        case 'ArrowRight':\r\n            return Direction.RIGHT;\r\n        case 'ArrowDown':\r\n            return Direction.DOWN;\r\n        case 'ArrowLeft':\r\n            return Direction.LEFT;\r\n        default:\r\n            return '';\r\n    }\r\n}\r\nexport const getOppostiteDirection= direction=>{\r\n    switch (direction) {\r\n        case Direction.UP:\r\n            return Direction.DOWN;\r\n        case Direction.RIGHT:\r\n            return Direction.LEFT;\r\n        case Direction.DOWN:\r\n            return Direction.UP;\r\n        case Direction.LEFT:\r\n            return Direction.RIGHT;\r\n        default:\r\n            break;\r\n    }\r\n}\r\nexport const getNextNodeDirection=(node,currentDirection)=>{\r\n    if(node.next===null)return currentDirection;\r\n    //since node value is an object with 3 values(row,col,cell)\r\n    //thereby destructuring it to obtain row and col\r\n    const {row:currentRow,col:currentCol}=node.value;\r\n    const {row:nextRow,col:nextCol}=node.next.value;\r\n    if(nextRow===currentRow && nextCol===currentCol+1){\r\n        return Direction.RIGHT;\r\n    }\r\n    if(nextRow===currentRow && nextCol===currentCol-1){\r\n        return Direction.LEFT;\r\n    }\r\n    if(nextCol===currentCol && nextRow===currentRow+1){\r\n        return Direction.DOWN;\r\n    }\r\n    if(nextCol===currentCol && nextRow===currentRow-1){\r\n        return Direction.UP;\r\n    }\r\n    return '';\r\n}\r\nexport const getNextCoordInDirection=(currentCoord,direction)=>{\r\n    switch (direction) {\r\n        case Direction.UP:\r\n            return{\r\n                row:currentCoord.row-1,\r\n                col:currentCoord.col\r\n            };\r\n            \r\n        case Direction.RIGHT:\r\n            return{\r\n                row:currentCoord.row,\r\n                col:currentCoord.col+1\r\n            };\r\n            \r\n        case Direction.DOWN:\r\n            return{\r\n                row:currentCoord.row+1,\r\n                col:currentCoord.col\r\n            };\r\n            \r\n        case Direction.LEFT:\r\n            return{\r\n                row:currentCoord.row,\r\n                col:currentCoord.col-1\r\n            };\r\n        default:\r\n            break;\r\n    }\r\n}\r\nexport const getGrowthNodeCoords=(snakeTail,currentDirection)=>{\r\n    //to obtain the current direction of movement of snake's tail based on it's neighbour node\r\n    //as there might be a case when snake's head is moving towards left and ate food but \r\n    //snake's tail is moving from right to left\r\n    const tailNextNodeDirection=getNextNodeDirection(snakeTail,currentDirection);\r\n    // console.log(tailNextNodeDirection);\r\n    const growthDirection=getOppostiteDirection(tailNextNodeDirection);\r\n    const currentTailCoords={\r\n        row:snakeTail.value.row,\r\n        col:snakeTail.value.col,\r\n    }\r\n    // console.log(growthDirection);\r\n    const growthNodeCoords=getNextCoordInDirection(currentTailCoords,growthDirection);\r\n    // console.log(growthNodeCoords);\r\n    return growthNodeCoords;\r\n}   \r\n","export default __webpack_public_path__ + \"static/media/snake.390985a6.png\";","import React from 'react';\r\nimport './aside.css';\r\nimport snakeImg from '../assets/snake.png';\r\nconst Aside = () => {\r\n    return (\r\n        <div className=\"aside\">\r\n            <img width=\"200px\" src={snakeImg} alt=\"snakeImage\" />\r\n            <div className=\"main\">\r\n                <h1 className=\"main-heading\">\r\n                    <span className=\"main-heading-primary\">Snake's</span><span className=\"main-heading-primary\" > Quest</span>\r\n                    <span className=\"main-heading-secondary\">Catch the food!!!</span>\r\n                </h1>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\nexport default Aside;","export default __webpack_public_path__ + \"static/media/borderGolden.17527f81.png\";","export default __webpack_public_path__ + \"static/media/apple.7edcac10.png\";","export default __webpack_public_path__ + \"static/media/borderLeaves.3ed63a73.png\";","export default __webpack_public_path__ + \"static/media/frog.d37ab703.png\";","import React,{useState,useEffect,useRef} from 'react';\r\nimport {createBoard,isOutOfBounds,getCellClassName} from '../utils/boardUtil';\r\nimport {SinglyLinkedList,LinkedListNode,reverseLinkedList} from '../utils/singlyLL';\r\nimport {getStartingSnakeCell,randomIntFromInterval} from '../utils/snakeUtil';\r\nimport {\r\n    Direction,\r\n    getDirectionFromKey,\r\n    getOppostiteDirection,\r\n    getGrowthNodeCoords,\r\n    getNextCoordInDirection,\r\n    getNextNodeDirection\r\n} from '../utils/coordUtil';\r\nimport {useInterval} from '../utils/intervalUtil';\r\nimport './board.css';\r\nimport Aside from './aside';\r\nimport scoreBoardImg from '../assets/borderGolden.png';\r\nimport appleImg from '../assets/apple.png';\r\nimport GreenBoard from '../assets/borderLeaves.png';\r\nimport frogImg from '../assets/frog.png';\r\nconst BOARD_SIZE=13;\r\nconst PROBABILITY_OF_DIRECTION_REVERSAL_FOOD=0.3;\r\n\r\nconst Board=()=>{\r\n\r\n    // eslint-disable-next-line no-unused-vars\r\n    const [board, setBoard] = useState(createBoard(BOARD_SIZE));\r\n    \r\n    //starting point of snake\r\n    const [snake, setSnake] = useState(\r\n        new SinglyLinkedList(getStartingSnakeCell(board))\r\n    );\r\n    const [snakeCells, setSnakeCells] = useState(\r\n        new Set([snake.head.value.cell])\r\n    )\r\n    //useRef can be used keep track of variables without causing re-render of the component\r\n    //Refs in React are used to store a reference to a React element and their values are persisted across re-render.\r\n    // Refs are mutable objects, hence they can be updated explicitly and\r\n    // can hold values other than a reference to a React element.\r\n    const snakeCellsHookRef=useRef(snakeCells);\r\n    const _setSnakeCells=newSnakeCells=>{\r\n        snakeCellsHookRef.current=newSnakeCells;\r\n        setSnakeCells(newSnakeCells);\r\n    }\r\n    //setting the starting food cell 5 cells away from starting snake cell\r\n    const [foodCell,setFoodCell]=useState(snake.head.value.cell+5);\r\n\r\n    const [direction, setDirection] = useState(Direction.RIGHT);//initially snake starts moving right\r\n    const directionHookRef=useRef(direction);\r\n    const _setDirection=direction=>{\r\n        directionHookRef.current=direction;\r\n        setDirection(direction);\r\n    }\r\n    \r\n    const [foodShouldReverseDirection, setFoodShouldReverseDirection]=useState(\r\n        false\r\n    );\r\n\r\n    const [score,setScore]=useState(0);\r\n\r\n    useEffect(()=>{\r\n        window.addEventListener('keydown',e=>{\r\n            handleKeydown(e);\r\n        });\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    },[]);\r\n\r\n    useInterval(()=>{\r\n        moveSnake();\r\n    },150);\r\n\r\n    const handleKeydown=e=>{\r\n        const newDirection=getDirectionFromKey(e.key);\r\n        const isValidDirection=newDirection!=='';\r\n        if(!isValidDirection)return;\r\n        //checking if new direction is exactly opposite of current direction\r\n        const snakeWillRunIntoItself=getOppostiteDirection(newDirection)===directionHookRef.current && snakeCellsHookRef.current.size>1;\r\n        if(snakeWillRunIntoItself)return;\r\n        _setDirection(newDirection);\r\n    }\r\n\r\n    const moveSnake=()=>{\r\n        const currentHeadCoordinates={\r\n            row:snake.head.value.row,\r\n            col:snake.head.value.col,\r\n        };\r\n\r\n        const nextHeadCoordinates=getNextCoordInDirection(currentHeadCoordinates,direction);\r\n  \r\n        if(isOutOfBounds(nextHeadCoordinates,board)){\r\n            handleGameOver();\r\n            return;\r\n        }\r\n        \r\n        const nextHeadCell=board[nextHeadCoordinates.row][nextHeadCoordinates.col];\r\n        // to check if next cell is already part of snake then snake collides with itself\r\n        if(snakeCells.has(nextHeadCell)){\r\n            handleGameOver();\r\n            return;\r\n        }\r\n        \r\n        const newHead=new LinkedListNode({\r\n            row:nextHeadCoordinates.row,\r\n            col:nextHeadCoordinates.col,\r\n            cell:nextHeadCell\r\n        });\r\n        //updating head\r\n        const currentHead=snake.head;//check it out\r\n        snake.head=newHead;\r\n        currentHead.next=newHead;\r\n\r\n        //updating cells in snake\r\n        const newSnakeCells=new Set(snakeCells);\r\n        newSnakeCells.delete(snake.tail.value.cell);\r\n        newSnakeCells.add(nextHeadCell);\r\n\r\n        //updating snake's tail\r\n        snake.tail=snake.tail.next;\r\n        if(snake.tail===null)snake.tail=snake.head;\r\n\r\n        // if food is consumed then grow\r\n        const foodConsumed= nextHeadCell===foodCell;\r\n        if(foodConsumed){\r\n            growSnake(newSnakeCells);\r\n            if(foodShouldReverseDirection){\r\n                reverseSnake();\r\n            }\r\n            handleFoodConsumption(newSnakeCells);\r\n        }\r\n        _setSnakeCells(newSnakeCells);\r\n    }\r\n\r\n    const growSnake= newSnakeCells => {\r\n        const growthNodeCoords=getGrowthNodeCoords(snake.tail,direction);\r\n        //if snake's tail is already bordering with boundaries then growth is restricted\r\n        //since direction of growth will be ambigous\r\n        if(isOutOfBounds(growthNodeCoords,board)){\r\n            return;\r\n        }\r\n        const newTailCell=board[growthNodeCoords.row][growthNodeCoords.col];\r\n        const newTail=new LinkedListNode({\r\n            row:growthNodeCoords.row,\r\n            col:growthNodeCoords.col,\r\n            cell:newTailCell\r\n        });\r\n        const currentTail=snake.tail;\r\n        snake.tail=newTail;\r\n        snake.tail.next=currentTail;\r\n        \r\n        newSnakeCells.add(newTailCell);\r\n        \r\n    }\r\n\r\n    const reverseSnake=()=>{\r\n        const tailNextNodeDirection=getNextNodeDirection(snake.tail,direction);\r\n        const newDirection=getOppostiteDirection(tailNextNodeDirection);\r\n        _setDirection(newDirection);\r\n        //tail of the snake is actually the head of linked list\r\n        //which is why we have to pass tail of the linked list to reverse snake\r\n        reverseLinkedList(snake.tail);\r\n        //after reversing head will become tail and vice-versa\r\n        //updating head and tail \r\n        const snakeHead=snake.head;\r\n        snake.head=snake.tail;\r\n        snake.tail=snakeHead;\r\n    }\r\n    const handleFoodConsumption= newSnakeCells=>{\r\n        const maxPossibleCellValue=BOARD_SIZE*BOARD_SIZE;\r\n        let nextFoodCell;\r\n        //food cell should be such that it's not already a snake cell or a food cell\r\n        \r\n        // In practice, this will never be a time-consuming operation. Even\r\n    // in the extreme scenario where a snake is so big that it takes up 90%\r\n    // of the board (nearly impossible), there would be a 10% chance of generating\r\n    // a valid new food cell--so an average of 10 operations: trivial.\r\n        while(true){\r\n            nextFoodCell=randomIntFromInterval(1,maxPossibleCellValue);\r\n            if(newSnakeCells.has(nextFoodCell) || foodCell===nextFoodCell) continue;\r\n            break;\r\n        }\r\n        const nextFoodShouldReverseDirection=Math.random()<PROBABILITY_OF_DIRECTION_REVERSAL_FOOD;\r\n        \r\n        setFoodCell(nextFoodCell);\r\n        setFoodShouldReverseDirection(nextFoodShouldReverseDirection);\r\n        if(foodShouldReverseDirection){//if food is frog then score double\r\n            setScore(score+2);\r\n        }else{\r\n            setScore(score+1);\r\n        }\r\n    }\r\n\r\n    const handleGameOver=()=>{\r\n        setScore(0);\r\n        const snakeLLStartingValue=getStartingSnakeCell(board);\r\n        setSnake(new SinglyLinkedList(snakeLLStartingValue));\r\n        setFoodCell(snakeLLStartingValue.cell+5);\r\n        setSnakeCells(new Set([snakeLLStartingValue.cell]));\r\n        setDirection(Direction.RIGHT);\r\n    }\r\n    \r\n    return(\r\n        <>\r\n            <Aside/>\r\n            <div className=\"boardContainer\" >\r\n                \r\n                <img style={{marginTop:\"-10px\"}} height=\"728px\" width=\"800px\" src={GreenBoard} alt=\"backBoard\"/>\r\n                \r\n                <div className=\"board\">\r\n                {board.map((row,rowInd)=>(\r\n                    <div key={rowInd} className=\"row\">\r\n                    {\r\n                        row.map((cellValue,cellInd)=>{\r\n                            const className=getCellClassName(\r\n                                cellValue,\r\n                                foodCell,\r\n                                foodShouldReverseDirection,\r\n                                snakeCells\r\n                            );\r\n                            return (\r\n                                <div key={cellInd} \r\n                                className={className}></div>\r\n                            )\r\n                        })\r\n                    }\r\n                    </div>\r\n                ))}\r\n                </div>\r\n            </div>\r\n            <div className=\"scoreBoard\">\r\n                <img width=\"320px\" height=\"320px\" src={scoreBoardImg} alt=\"scoreBoardLayout\" />\r\n                <p>\r\n                    <span style={{textDecorationLine:\"underline\"}} >Score </span>\r\n                    <br/>\r\n                    <img width=\"100px\" height=\"100px\" style={{marginTop:\"0px\",marginLeft:\"-100px\"}} src={appleImg} alt=\"apple.png\" />\r\n                    <span style={{position:\"absolute\",color:\"red\",marginTop:\"30px\",marginLeft:\"0px\"}}><strong>{score}</strong></span>\r\n                    <img width=\"100px\" height=\"100px\" style={{marginTop:\"0px\",marginLeft:\"30px\",marginRight:\"-100px\"}} src={frogImg} alt=\"frog.png\" />\r\n                </p>\r\n            </div>\r\n        </>\r\n    )\r\n}\r\nexport default Board;","import {useEffect,useRef} from 'react';\r\n\r\nexport function useInterval(callback,delay){\r\n    const savedCallback=useRef();\r\n    //updating latest callback\r\n    useEffect(()=>{\r\n        savedCallback.current=callback;\r\n    },[callback]);\r\n    \r\n    //setup the interval\r\n    useEffect(()=>{\r\n        function tick(){\r\n            savedCallback.current();\r\n        }\r\n        if(delay!==null){\r\n            let id=setInterval(tick,delay);\r\n            return ()=>clearInterval(id);\r\n        }\r\n    },[delay]);\r\n}\r\n","import './App.css';\nimport Board from './board/board';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Board/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}