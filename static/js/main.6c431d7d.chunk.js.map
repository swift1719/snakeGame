{"version":3,"sources":["board/board.js","utils.js","App.js","index.js"],"names":["LinkedListNode","value","this","next","SinglyLinkedList","node","head","tail","createBoard","BOARD_SIZE","counter","board","row","currentRow","col","push","getStartingSnakeLLValue","rowSize","length","colSize","startingRow","Math","round","startingCol","cell","isOutOfBounds","coordinates","getDirectionFromKey","key","Direction","UP","RIGHT","DOWN","LEFT","getNextNodeDirection","currentDirection","currentCol","nextRow","nextCol","getNextHeadCoordinates","currentHeadCoordinates","direction","getGrowthNodeCoords","snakeTail","tailNextNodeDirection","growthDirection","getOppostiteDirection","getCoordinatesInDirection","getCellClassName","cellValue","foodCell","foodShouldReverseDirection","snakeCells","className","has","Board","useState","snake","setSnake","Set","setSnakeCells","snakeCellsHookRef","useRef","setFoodCell","setDirection","directionHookRef","_setDirection","current","setFoodShouldReverseDirection","score","setScore","useEffect","window","addEventListener","e","handleKeydown","callback","delay","savedCallback","id","setInterval","clearInterval","useInterval","moveSnake","newDirection","size","nextHeadCoordinates","handleGameOver","nextHeadCell","newHead","currentHead","newSnakeCells","delete","add","growSnake","reverseSnake","handleFoodConsumption","_setSnakeCells","growthNodeCoords","newTailCell","newTail","currentTail","previousNode","currentNode","nextNode","reverseLinkedList","snakeHead","nextFoodCell","min","max","floor","random","nextFoodShouldReverseDirection","snakeLLStartingValue","map","rowInd","cellInd","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.6c431d7d.chunk.js","sourcesContent":["import React,{useState,useEffect,useRef} from 'react';\r\nimport {useInterval,randomIntFromInterval,reverseLinkedList} from '../utils';\r\nimport './board.css';\r\n\r\nclass LinkedListNode{\r\n    constructor(value){\r\n        this.value=value;\r\n        this.next=null;\r\n    }\r\n}\r\nclass SinglyLinkedList{\r\n    constructor(value){\r\n        const node=new LinkedListNode(value);\r\n        this.head=node;\r\n        this.tail=node;\r\n    }\r\n}\r\n\r\nconst BOARD_SIZE=13;\r\nconst PROBABILITY_OF_DIRECTION_REVERSAL_FOOD=0.3;\r\n\r\nconst Board=()=>{\r\n\r\n    // eslint-disable-next-line no-unused-vars\r\n    const [board, setBoard] = useState(createBoard(BOARD_SIZE));\r\n    \r\n    //starting point of snake\r\n    const [snake, setSnake] = useState(\r\n        new SinglyLinkedList(getStartingSnakeLLValue(board))\r\n    );\r\n    const [snakeCells, setSnakeCells] = useState(\r\n        new Set([snake.head.value.cell])\r\n    )\r\n    const snakeCellsHookRef=useRef(snakeCells);\r\n    const _setSnakeCells=newSnakeCells=>{\r\n        snakeCellsHookRef.current=newSnakeCells;\r\n        setSnakeCells(newSnakeCells);\r\n    }\r\n    //setting the starting food cell 5 cells away from starting snake cell\r\n    const [foodCell,setFoodCell]=useState(snake.head.value.cell+5);\r\n\r\n    const [direction, setDirection] = useState(Direction.RIGHT);//initially snake starts moving right\r\n    const directionHookRef=useRef(direction);\r\n    const _setDirection=direction=>{\r\n        directionHookRef.current=direction;\r\n        setDirection(direction);\r\n    }\r\n    \r\n    const [foodShouldReverseDirection, setFoodShouldReverseDirection]=useState(\r\n        false\r\n    );\r\n\r\n    const [score,setScore]=useState(0);\r\n\r\n    useEffect(()=>{\r\n        window.addEventListener('keydown',e=>{\r\n            handleKeydown(e);\r\n        });\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    },[]);\r\n\r\n    useInterval(()=>{\r\n        moveSnake();\r\n    },150);\r\n\r\n    const handleKeydown=e=>{\r\n        const newDirection=getDirectionFromKey(e.key);\r\n        const isValidDirection=newDirection!=='';\r\n        if(!isValidDirection)return;\r\n        //checking if new direction is exactly opposite of current direction\r\n        const snakeWillRunIntoItself=getOppostiteDirection(newDirection)===directionHookRef.current && snakeCellsHookRef.current.size>1;\r\n        if(snakeWillRunIntoItself)return;\r\n        _setDirection(newDirection);\r\n    }\r\n\r\n    const moveSnake=()=>{\r\n        const currentHeadCoordinates={\r\n            row:snake.head.value.row,\r\n            col:snake.head.value.col,\r\n        };\r\n\r\n        const nextHeadCoordinates=getNextHeadCoordinates(currentHeadCoordinates,direction);\r\n  \r\n        if(isOutOfBounds(nextHeadCoordinates,board)){\r\n            handleGameOver();\r\n            return;\r\n        }\r\n        \r\n        const nextHeadCell=board[nextHeadCoordinates.row][nextHeadCoordinates.col];\r\n        // to check if next cell is already part of snake then snake collides with itself\r\n        if(snakeCells.has(nextHeadCell)){\r\n            handleGameOver();\r\n            return;\r\n        }\r\n        \r\n        const newHead=new LinkedListNode({\r\n            row:nextHeadCoordinates.row,\r\n            col:nextHeadCoordinates.col,\r\n            cell:nextHeadCell\r\n        });\r\n        //updating head\r\n        const currentHead=snake.head;//check it out\r\n        snake.head=newHead;\r\n        currentHead.next=newHead;\r\n\r\n        //updating cells in snake\r\n        const newSnakeCells=new Set(snakeCells);\r\n        newSnakeCells.delete(snake.tail.value.cell);\r\n        newSnakeCells.add(nextHeadCell);\r\n\r\n        //updating snake's tail\r\n        snake.tail=snake.tail.next;\r\n        if(snake.tail===null)snake.tail=snake.head;\r\n\r\n        // if food is consumed then grow\r\n        const foodConsumed= nextHeadCell===foodCell;\r\n        if(foodConsumed){\r\n            growSnake(newSnakeCells);\r\n            if(foodShouldReverseDirection){\r\n                reverseSnake();\r\n            }\r\n            handleFoodConsumption(newSnakeCells);\r\n        }\r\n        _setSnakeCells(newSnakeCells);\r\n    }\r\n\r\n    const growSnake= newSnakeCells => {\r\n        const growthNodeCoords=getGrowthNodeCoords(snake.tail,direction);\r\n        if(isOutOfBounds(growthNodeCoords,board)){\r\n            return;\r\n        }\r\n        const newTailCell=board[growthNodeCoords.row][growthNodeCoords.col];\r\n        const newTail=new LinkedListNode({\r\n            row:growthNodeCoords.row,\r\n            col:growthNodeCoords.col,\r\n            cell:newTailCell\r\n        });\r\n        const currentTail=snake.tail;\r\n        snake.tail=newTail;\r\n        snake.tail.next=currentTail;\r\n        \r\n        newSnakeCells.add(newTailCell);\r\n        \r\n    }\r\n\r\n    const reverseSnake=()=>{\r\n        const tailNextNodeDirection=getNextNodeDirection(snake.tail,direction);\r\n        const newDirection=getOppostiteDirection(tailNextNodeDirection);\r\n        _setDirection(newDirection);\r\n        //tail of the snake is actually the head of linked list\r\n        //which is why we have to pass tail of the linked list to reverse snake\r\n        reverseLinkedList(snake.tail);\r\n        //after reversing head will become tail and vice-versa\r\n        //updating head and tail \r\n        const snakeHead=snake.head;\r\n        snake.head=snake.tail;\r\n        snake.tail=snakeHead;\r\n    }\r\n    const handleFoodConsumption= newSnakeCells=>{\r\n        const maxPossibleCellValue=BOARD_SIZE*BOARD_SIZE;\r\n        let nextFoodCell;\r\n        //food cell should be such that it's not already a snake cell or a food cell\r\n        \r\n        // In practice, this will never be a time-consuming operation. Even\r\n    // in the extreme scenario where a snake is so big that it takes up 90%\r\n    // of the board (nearly impossible), there would be a 10% chance of generating\r\n    // a valid new food cell--so an average of 10 operations: trivial.\r\n        while(true){\r\n            nextFoodCell=randomIntFromInterval(1,maxPossibleCellValue);\r\n            if(newSnakeCells.has(nextFoodCell) || foodCell===nextFoodCell) continue;\r\n            break;\r\n        }\r\n        const nextFoodShouldReverseDirection=Math.random()<PROBABILITY_OF_DIRECTION_REVERSAL_FOOD;\r\n        \r\n        setFoodCell(nextFoodCell);\r\n        setFoodShouldReverseDirection(nextFoodShouldReverseDirection);\r\n        setScore(score+1);\r\n    }\r\n\r\n    const handleGameOver=()=>{\r\n        setScore(0);\r\n        const snakeLLStartingValue=getStartingSnakeLLValue(board);\r\n        setSnake(new SinglyLinkedList(snakeLLStartingValue));\r\n        setFoodCell(snakeLLStartingValue.cell+5);\r\n        setSnakeCells(new Set([snakeLLStartingValue.cell]));\r\n        setDirection(Direction.RIGHT);\r\n    }\r\n    \r\n    return(\r\n        <>\r\n            <h1>Score: {score}</h1>\r\n            <div className=\"board\">\r\n            {board.map((row,rowInd)=>(\r\n                <div key={rowInd} className=\"row\">\r\n                {\r\n                    row.map((cellValue,cellInd)=>{\r\n                        const className=getCellClassName(\r\n                            cellValue,\r\n                            foodCell,\r\n                            foodShouldReverseDirection,\r\n                            snakeCells\r\n                        );\r\n                        return (\r\n                            <div key={cellInd} \r\n                            className={className}></div>\r\n                        )\r\n                    })\r\n                }\r\n                </div>\r\n            ))}\r\n            </div>\r\n        </>\r\n    )\r\n}\r\n\r\nconst createBoard = BOARD_SIZE => {\r\n    let counter=1;\r\n    const board=[];\r\n\r\n    for(let row=0;row<BOARD_SIZE;row++){\r\n        const currentRow=[];\r\n        for(let col=0;col<BOARD_SIZE;col++){\r\n            currentRow.push(counter++);\r\n        }//every cell of board has a unique counter\r\n        board.push(currentRow);\r\n    }\r\n    return board;\r\n}\r\n\r\nconst getCoordinatesInDirection=(coordinates,direction)=>{\r\n    switch (direction) {\r\n        case Direction.UP:\r\n            return{\r\n                row:coordinates.row-1,\r\n                col:coordinates.col\r\n            };\r\n            \r\n        case Direction.RIGHT:\r\n            return{\r\n                row:coordinates.row,\r\n                col:coordinates.col+1\r\n            };\r\n            \r\n        case Direction.DOWN:\r\n            return{\r\n                row:coordinates.row+1,\r\n                col:coordinates.col\r\n            };\r\n            \r\n        case Direction.LEFT:\r\n            return{\r\n                row:coordinates.row,\r\n                col:coordinates.col-1\r\n            };\r\n        default:\r\n            break;\r\n    }\r\n}\r\n\r\nconst getStartingSnakeLLValue=board=>{\r\n    const rowSize = board.length;\r\n    const colSize = board[0].length;\r\n    const startingRow=Math.round(rowSize/3);\r\n    const startingCol=Math.round(colSize/3);\r\n    const startingCell=board[startingRow][startingCol];\r\n    return{\r\n        row:startingRow,\r\n        col:startingCol,\r\n        cell:startingCell\r\n    }\r\n}\r\n\r\nconst isOutOfBounds=(coordinates,board)=>{\r\n    const {row,col}=coordinates;\r\n    if(row<0 || col<0)return true;\r\n    if(row>=board.length || col>=board[0].length)return true;\r\n    return false;\r\n}\r\nconst getDirectionFromKey = key=>{\r\n    switch (key) {\r\n        case 'ArrowUp':\r\n            return Direction.UP;\r\n        case 'ArrowRight':\r\n            return Direction.RIGHT;\r\n        case 'ArrowDown':\r\n            return Direction.DOWN;\r\n        case 'ArrowLeft':\r\n            return Direction.LEFT;\r\n        default:\r\n            return '';\r\n    }\r\n}\r\n//hashtable to return direction\r\nconst Direction={\r\n    UP:'UP',\r\n    RIGHT:'RIGHT',\r\n    DOWN:'DOWN',\r\n    LEFT:'LEFT',\r\n};\r\n\r\nconst getNextNodeDirection=(node,currentDirection)=>{\r\n    if(node.next===null)return currentDirection;\r\n    const {row:currentRow,col:currentCol}=node.value;\r\n    const {row:nextRow,col:nextCol}=node.next.value;\r\n    if(nextRow===currentRow && nextCol===currentCol+1){\r\n        return Direction.RIGHT;\r\n    }\r\n    if(nextRow===currentRow && nextCol===currentCol-1){\r\n        return Direction.LEFT;\r\n    }\r\n    if(nextCol===currentCol && nextRow===currentRow+1){\r\n        return Direction.DOWN;\r\n    }\r\n    if(nextCol===currentCol && nextRow===currentRow-1){\r\n        return Direction.UP;\r\n    }\r\n    return '';\r\n}\r\nconst getNextHeadCoordinates=(currentHeadCoordinates,direction)=>{\r\n    switch (direction) {\r\n        case Direction.UP:\r\n            return{\r\n                row:currentHeadCoordinates.row-1,\r\n                col:currentHeadCoordinates.col\r\n            };\r\n            \r\n        case Direction.RIGHT:\r\n            return{\r\n                row:currentHeadCoordinates.row,\r\n                col:currentHeadCoordinates.col+1\r\n            };\r\n            \r\n        case Direction.DOWN:\r\n            return{\r\n                row:currentHeadCoordinates.row+1,\r\n                col:currentHeadCoordinates.col\r\n            };\r\n            \r\n        case Direction.LEFT:\r\n            return{\r\n                row:currentHeadCoordinates.row,\r\n                col:currentHeadCoordinates.col-1\r\n            };\r\n        default:\r\n            break;\r\n    }\r\n}\r\nconst getGrowthNodeCoords=(snakeTail,currentDirection)=>{\r\n    const tailNextNodeDirection=getNextNodeDirection(snakeTail,currentDirection);\r\n    // console.log(tailNextNodeDirection);\r\n    const growthDirection=getOppostiteDirection(tailNextNodeDirection);\r\n    const currentTailCoords={\r\n        row:snakeTail.value.row,\r\n        col:snakeTail.value.col,\r\n    }\r\n    // console.log(growthDirection);\r\n    const growthNodeCoords=getCoordinatesInDirection(currentTailCoords,growthDirection);\r\n    // console.log(growthNodeCoords);\r\n    return growthNodeCoords;\r\n}   \r\nconst getOppostiteDirection= direction=>{\r\n    switch (direction) {\r\n        case Direction.UP:\r\n            return Direction.DOWN;\r\n        case Direction.RIGHT:\r\n            return Direction.LEFT;\r\n        case Direction.DOWN:\r\n            return Direction.UP;\r\n        case Direction.LEFT:\r\n            return Direction.RIGHT;\r\n        default:\r\n            break;\r\n    }\r\n}\r\n\r\nconst getCellClassName=(cellValue,foodCell,foodShouldReverseDirection,snakeCells)=>{\r\n    let className='cell';\r\n    if(cellValue===foodCell){\r\n        if(foodShouldReverseDirection){\r\n            className ='cell cell-purple';\r\n        }else{\r\n            className='cell cell-red';\r\n        }\r\n    }\r\n    if(snakeCells.has(cellValue)){\r\n        className='cell cell-green';\r\n    }\r\n    return className;\r\n}\r\n\r\nexport default Board;","import {useEffect,useRef} from 'react';\r\n\r\nexport function randomIntFromInterval(min,max){\r\n    return Math.floor(Math.random()*(max-min+1)+min)\r\n}\r\n\r\nexport function useInterval(callback,delay){\r\n    const savedCallback=useRef();\r\n    //updating latest callback\r\n    useEffect(()=>{\r\n        savedCallback.current=callback;\r\n    },[callback]);\r\n    \r\n    //setup the interval\r\n    useEffect(()=>{\r\n        function tick(){\r\n            savedCallback.current();\r\n        }\r\n        if(delay!==null){\r\n            let id=setInterval(tick,delay);\r\n            return ()=>clearInterval(id);\r\n        }\r\n    },[delay]);\r\n}\r\nexport function reverseLinkedList(head){\r\n    let previousNode=null;\r\n    let currentNode=head;\r\n    while(currentNode!==null){\r\n        const nextNode=currentNode.next;\r\n        currentNode.next=previousNode;\r\n        previousNode=currentNode;\r\n        currentNode=nextNode;\r\n    }\r\n    return previousNode;\r\n}","import './App.css';\nimport Board from './board/board';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Board/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}